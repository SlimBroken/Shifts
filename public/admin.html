<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Admin Dashboard - Shift Schedule Manager</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: linear-gradient(135deg, #e3f2fd 0%, #bbdefb 50%, #90caf9 100%);
            border-radius: 15px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.3);
            overflow: hidden;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.3);
        }

        .header {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
            color: white;
            padding: 30px;
            text-align: center;
            position: relative;
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
        }

        .content {
            padding: 30px;
        }

        .btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 12px 30px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            font-weight: 600;
            transition: transform 0.2s ease;
            margin-right: 10px;
            margin-bottom: 10px;
        }

        .btn:hover {
            transform: translateY(-2px);
        }

        .btn-secondary {
            background: linear-gradient(135deg, #ffeaa7 0%, #fab1a0 100%);
        }

        .btn-success {
            background: linear-gradient(135deg, #00b894 0%, #00cec9 100%);
        }

        .btn-danger {
            background: linear-gradient(135deg, #ff7675 0%, #fd79a8 100%);
        }

        .btn-warning {
            background: linear-gradient(135deg, #fdcb6e 0%, #e17055 100%);
        }

        .workers-list {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }

        .worker-card {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 10px;
            border: 1px solid #dee2e6;
            transition: transform 0.2s ease;
        }

        .worker-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(0,0,0,0.1);
        }

        .worker-card h3 {
            color: #495057;
            margin-bottom: 10px;
        }

        .worker-card.approved {
            border-color: #28a745;
            background: #f8fff9;
        }

        .alert {
            padding: 15px;
            margin: 15px 0;
            border-radius: 8px;
            font-weight: 500;
        }

        .alert-success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        .alert-info {
            background: #d1ecf1;
            color: #0c5460;
            border: 1px solid #bee5eb;
        }

        .alert-warning {
            background: #fff3cd;
            color: #856404;
            border: 1px solid #ffeaa7;
        }

        .alert-danger {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }

        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }

        .stat-card {
            background: linear-gradient(135deg, #74b9ff 0%, #0984e3 100%);
            color: white;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
        }

        .stat-number {
            font-size: 2em;
            font-weight: bold;
            margin-bottom: 5px;
        }

        .admin-actions {
            background: #e9ecef;
            padding: 20px;
            border-radius: 10px;
            margin: 20px 0;
        }

        .password-section {
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 20px;
        }

        .password-input {
            display: flex;
            gap: 10px;
            align-items: center;
            margin-top: 10px;
        }

        .password-input input {
            padding: 8px 12px;
            border: 1px solid #ced4da;
            border-radius: 4px;
            font-size: 14px;
        }

        .lock-control {
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            border-radius: 10px;
            padding: 20px;
            margin: 20px 0;
        }

        .lock-status {
            margin: 15px 0;
            padding: 15px;
            border-radius: 5px;
            font-weight: bold;
        }

        .lock-status.locked {
            background: #f8d7da;
            border: 1px solid #f5c6cb;
            color: #721c24;
        }

        .lock-status.unlocked {
            background: #d4edda;
            border: 1px solid #c3e6cb;
            color: #155724;
        }

        .sync-status {
            background: #e9ecef;
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
        }

        .sync-status.connected {
            background: #d4edda;
            border: 1px solid #c3e6cb;
        }

        .sync-status.disconnected {
            background: #f8d7da;
            border: 1px solid #f5c6cb;
        }

        .server-info {
            background: #e7f3ff;
            border: 1px solid #b8daff;
            border-radius: 8px;
            padding: 15px;
            margin: 15px 0;
        }

        .hidden {
            display: none;
        }

        .schedule-container {
            background: #f8f9fa;
            border-radius: 10px;
            padding: 20px;
            margin: 20px 0;
        }

        .schedule-table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
            background: white;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        .schedule-table th {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
            color: white;
            padding: 12px;
            border: 1px solid #ddd;
            text-align: center;
        }

        .schedule-table td {
            padding: 12px;
            border: 1px solid #ddd;
            text-align: center;
        }

        .shift-assigned {
            background: #d4edda;
            color: #155724;
        }

        .shift-unfilled {
            background: #f8d7da;
            color: #721c24;
        }

        .weekend-row {
            background: #fff3cd;
        }

        .worker-stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }

        .worker-stat-card {
            background: white;
            padding: 15px;
            border-radius: 5px;
            border: 1px solid #dee2e6;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üîß Admin Dashboard</h1>
            <p>Server-Based Shift Schedule Manager</p>
        </div>

        <div class="content">
            <!-- Simple Password Protection -->
            <div id="passwordSection" class="password-section">
                <h3>üîí Admin Access Required</h3>
                <p>Enter the admin password to access the dashboard:</p>
                <div class="password-input">
                    <input type="password" id="adminPassword" placeholder="Enter admin password">
                    <button class="btn" onclick="checkPassword()">Access Dashboard</button>
                </div>
                <small>Default password: admin123 (change this in production!)</small>
            </div>

            <div id="adminContent" class="hidden">
                <!-- Server Connection Status -->
                <div id="serverInfo" class="server-info">
                    <h4>üñ•Ô∏è Server Connection Status</h4>
                    <div id="connectionStatus">
                        üîÑ Testing server connection...
                    </div>
                </div>

                <!-- Sync Status Display -->
                <div id="syncStatusDisplay" class="sync-status">
                    <h4>üîÑ Data Synchronization Status</h4>
                    <div id="syncStatusContent">
                        <div>üîÑ Initializing sync...</div>
                    </div>
                </div>

                <!-- Statistics -->
                <div class="stats">
                    <div class="stat-card">
                        <div class="stat-number" id="totalSubmissions">0</div>
                        <div>Total Submissions</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-number" id="pendingApprovals">0</div>
                        <div>Pending Approvals</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-number" id="approvedWorkersCount">0</div>
                        <div>Approved Workers</div>
                    </div>
                </div>

                <!-- Preference Lock Control -->
                <div class="lock-control">
                    <h3>üîí Preference Submission Control</h3>
                    <p>Lock worker preferences during schedule generation to prevent changes.</p>
                    
                    <div id="lockStatus" class="lock-status">
                        <!-- Will be populated by JavaScript -->
                    </div>
                    
                    <div style="margin-top: 15px;">
                        <button class="btn" id="toggleLockBtn" onclick="togglePreferenceLock()">
                            <!-- Text will be set by JavaScript -->
                        </button>
                        <small style="display: block; margin-top: 10px; color: #856404;">
                            <strong>Tip:</strong> Lock preferences before generating schedules to ensure data consistency.
                        </small>
                    </div>
                </div>

                <!-- Admin Actions -->
                <div class="admin-actions">
                    <h3>Quick Actions</h3>
                    <button class="btn btn-secondary" onclick="exportSchedule()">üìä Export Schedule (CSV)</button>
                    <button class="btn" onclick="copyExcelFormat()">üìã Copy Excel Format</button>
                    <button class="btn" onclick="refreshData()">üîÑ Refresh Data</button>
                    <button class="btn" onclick="manualSync()" id="syncBtn">üîÑ Sync Now</button>
                    <button class="btn" onclick="testServerConnection()" id="testBtn">üîç Test Connection</button>
                    <button class="btn btn-danger" onclick="clearAllData()">üóëÔ∏è Clear All Data</button>
                    
                    <div id="syncResult" style="margin-top: 10px; font-size: 12px;">
                        <!-- Sync results will be shown here -->
                    </div>
                </div>

                <!-- Worker Access Management -->
                <div style="background: #f8f9fa; padding: 20px; border-radius: 10px; margin: 20px 0;">
                    <h3>üë• Worker Access Management</h3>
                    <p>Manage which workers can access the shift preference system.</p>
                    <div style="background: #fff3cd; padding: 10px; border-radius: 5px; margin: 10px 0; font-size: 14px;">
                        <strong>‚ö†Ô∏è Important:</strong> Only workers added to this list can submit shift preferences.
                    </div>
                    
                    <div style="margin: 15px 0;">
                        <div style="display: flex; gap: 10px; align-items: center;">
                            <input type="text" id="newWorkerName" placeholder="Enter worker name" style="flex: 1; padding: 8px;">
                            <button class="btn btn-success" onclick="addWorker()">Add Worker</button>
                        </div>
                    </div>

                    <div id="approvedWorkersList">
                        <!-- Will be populated by JavaScript -->
                    </div>

                    <div style="margin-top: 15px; padding: 10px; background: #e9ecef; border-radius: 5px;">
                        <h5>üîç Test Access Control:</h5>
                        <div style="display: flex; gap: 10px; align-items: center; margin-top: 10px;">
                            <input type="text" id="testWorkerName" placeholder="Enter name to test" style="flex: 1; padding: 6px;">
                            <button class="btn" onclick="testWorkerAccess()" style="padding: 6px 12px; font-size: 14px;">Test Access</button>
                        </div>
                        <div id="testResult" style="margin-top: 10px;"></div>
                    </div>
                </div>

                <!-- Worker Submissions -->
                <h3>Worker Submissions</h3>
                <div id="workerSubmissions" class="workers-list">
                    <!-- Will be populated by JavaScript -->
                </div>

                <!-- Schedule Generation -->
                <div style="margin: 30px 0; text-align: center;">
                    <button class="btn btn-success" onclick="generateSchedule()" style="font-size: 18px; padding: 15px 40px;">
                        üîÑ Generate Optimized Schedule
                    </button>
                    <div id="generationCounter" style="margin-top: 10px; font-size: 14px; color: #6c757d;">
                        <!-- Will show generation count after first generation -->
                    </div>
                </div>

                <!-- Generated Schedule -->
                <h3>Generated Schedule</h3>
                <div id="generatedSchedule">
                    <div class="alert alert-info">No schedule generated yet. Click "Generate Optimized Schedule" to create one.</div>
                </div>
            </div>
        </div>
    </div>

    <script>
        let workerSubmissions = [];
        let generatedScheduleData = null;
        let currentGeneration = 0;
        let totalPossibleGenerations = 0;
        const ADMIN_PASSWORD = 'admin123'; // Change this in production!
        
        // Server-based configuration - no tokens needed in frontend!
        const syncEnabled = true; // Server handles authentication
        let lastSyncTime = null;
        let syncIntervalId = null;
        let serverConnected = false;

        // Initialize the application
        document.addEventListener('DOMContentLoaded', function() {
            console.log('üöÄ Admin Dashboard starting (Server-based)...');
            
            // Password enter key support
            document.getElementById('adminPassword').addEventListener('keypress', function(e) {
                if (e.key === 'Enter') {
                    checkPassword();
                }
            });
        });

        async function testServerConnection() {
            const testBtn = document.getElementById('testBtn');
            testBtn.textContent = 'üîÑ Testing...';
            testBtn.disabled = true;
            
            try {
                const response = await fetch('/api/test');
                const result = await response.json();
                
                if (result.success) {
                    updateConnectionStatus(`‚úÖ Connected as ${result.user}`, 'success');
                    serverConnected = true;
                    showSyncResult('‚úÖ Server connection successful', 'success');
                } else {
                    updateConnectionStatus('‚ùå Server connection failed: ' + result.error, 'error');
                    serverConnected = false;
                    showSyncResult('‚ùå Connection failed', 'error');
                }
            } catch (error) {
                updateConnectionStatus('‚ùå Cannot reach server: ' + error.message, 'error');
                serverConnected = false;
                showSyncResult('‚ùå Server unreachable', 'error');
            } finally {
                testBtn.textContent = 'üîç Test Connection';
                testBtn.disabled = false;
            }
        }

        function updateConnectionStatus(message, type) {
            const statusDiv = document.getElementById('connectionStatus');
            const colors = {
                success: 'green',
                error: 'red',
                info: 'blue',
                warning: 'orange'
            };
            statusDiv.style.color = colors[type] || 'black';
            statusDiv.innerHTML = message;
        }

        async function initialSync() {
            console.log('üîÑ Starting initial sync...');
            updateSyncStatus('Connecting to server...', 'info');
            
            try {
                // Test server connection first
                await testServerConnection();
                
                if (serverConnected) {
                    const success = await syncFromGitHub();
                    if (success) {
                        console.log('‚úÖ Initial sync from server successful');
                        updateSyncStatus('Connected to server - Data synchronized', 'success');
                        
                        // Auto-sync every 30 seconds
                        if (syncIntervalId) clearInterval(syncIntervalId);
                        syncIntervalId = setInterval(() => {
                            console.log('‚è∞ Auto-sync triggered');
                            syncFromGitHub();
                        }, 30000);
                    } else {
                        console.log('‚ö†Ô∏è Server sync failed, loading local data');
                        loadSubmissions();
                        updateSyncStatus('Server sync failed - Using local data', 'warning');
                    }
                } else {
                    loadSubmissions();
                    updateSyncStatus('Server not available - Using local data', 'warning');
                }
            } catch (error) {
                console.error('‚ùå Initial sync error:', error);
                loadSubmissions();
                updateSyncStatus('Sync error - Using local data only', 'error');
            }
        }

        // Updated sync functions for server-based approach
        async function syncToGitHub(data) {
            if (!serverConnected) {
                console.log('‚ùå Server not connected');
                return false;
            }
            
            try {
                console.log('üì§ Syncing data to server...');
                
                const response = await fetch('/api/data', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(data)
                });

                const result = await response.json();
                
                if (result.success) {
                    console.log('‚úÖ Data synced to server successfully');
                    lastSyncTime = Date.now();
                    localStorage.setItem('lastSyncTime', lastSyncTime.toString());
                    updateSyncStatus('Last sync: ' + new Date().toLocaleTimeString(), 'success');
                    showSyncResult('‚úÖ Synced to server', 'success');
                    return true;
                } else {
                    console.error('‚ùå Failed to sync to server:', result.error);
                    updateSyncStatus('Upload failed: ' + result.error, 'error');
                    showSyncResult('‚ùå Upload failed', 'error');
                    return false;
                }
            } catch (error) {
                console.error('‚ùå Sync to server error:', error);
                updateSyncStatus('Upload error: ' + error.message, 'error');
                showSyncResult('‚ùå Upload error', 'error');
                return false;
            }
        }

        async function syncFromGitHub() {
            if (!serverConnected) {
                console.log('‚ùå Server not connected');
                return false;
            }
            
            try {
                console.log('üì• Syncing from server...');
                
                const response = await fetch('/api/data');
                const result = await response.json();
                
                if (result.success) {
                    const data = result.data;
                    console.log('üì¶ Server data received:', Object.keys(data));
                    
                    workerSubmissions = data.shiftSubmissions || [];
                    localStorage.setItem('shiftSubmissions', JSON.stringify(workerSubmissions));
                    localStorage.setItem('approvedWorkers', JSON.stringify(data.approvedWorkers || []));
                    localStorage.setItem('preferencesLocked', data.preferencesLocked ? 'true' : 'false');
                    localStorage.setItem('lockTimestamp', data.lockTimestamp || '');
                    localStorage.setItem('lastUpdate', (data.lastUpdate || Date.now()).toString());
                    
                    lastSyncTime = Date.now();
                    localStorage.setItem('lastSyncTime', lastSyncTime.toString());
                    
                    console.log('‚úÖ Data updated from server');
                    updateSyncStatus('Last sync: ' + new Date().toLocaleTimeString(), 'success');
                    
                    if (!document.getElementById('adminContent').classList.contains('hidden')) {
                        updateAdminDashboard();
                    }
                    
                    return true;
                } else {
                    console.error('‚ùå Server API error:', result.error);
                    updateSyncStatus('Download failed: ' + result.error, 'error');
                    return false;
                }
            } catch (error) {
                console.error('‚ùå Failed to sync from server:', error);
                updateSyncStatus('Download error: ' + error.message, 'error');
                return false;
            }
        }

        function updateSyncStatus(message, type) {
            const statusDiv = document.getElementById('syncStatusDisplay');
            const contentDiv = document.getElementById('syncStatusContent');
            
            let statusClass = 'sync-status';
            let icon = 'üîÑ';
            
            switch(type) {
                case 'success':
                    statusClass += ' connected';
                    icon = '‚úÖ';
                    break;
                case 'error':
                    statusClass += ' disconnected';
                    icon = '‚ùå';
                    break;
                case 'warning':
                    statusClass += ' disconnected';
                    icon = '‚ö†Ô∏è';
                    break;
                default:
                    icon = 'üîÑ';
            }
            
            statusDiv.className = statusClass;
            
            const timeStr = new Date().toLocaleTimeString();
            contentDiv.innerHTML = `
                <div style="display: flex; justify-content: space-between; align-items: center;">
                    <span>${icon} ${message}</span>
                    <small>${timeStr}</small>
                </div>
                <div style="margin-top: 5px; font-size: 12px; opacity: 0.8;">
                    Server-based sync | Auto-sync every 30s
                </div>
            `;
        }

        function showSyncResult(message, type) {
            const resultDiv = document.getElementById('syncResult');
            const className = type === 'success' ? 'color: green' : 'color: red';
            resultDiv.innerHTML = `<div style="${className}; font-weight: bold;">${message}</div>`;
            
            setTimeout(() => {
                resultDiv.innerHTML = '';
            }, 3000);
        }

        function checkPassword() {
            const password = document.getElementById('adminPassword').value;
            if (password === ADMIN_PASSWORD) {
                document.getElementById('passwordSection').classList.add('hidden');
                document.getElementById('adminContent').classList.remove('hidden');
                
                // Initialize everything after login
                initialSync();
                updateAdminDashboard();
            } else {
                alert('Incorrect password. Please try again.');
                document.getElementById('adminPassword').value = '';
            }
        }

        function loadSubmissions() {
            const stored = localStorage.getItem('shiftSubmissions');
            workerSubmissions = stored ? JSON.parse(stored) : [];
            console.log('üìÅ Loaded submissions from localStorage:', workerSubmissions.length);
        }

        function saveSubmissions() {
            localStorage.setItem('shiftSubmissions', JSON.stringify(workerSubmissions));
            localStorage.setItem('lastUpdate', Date.now().toString());
            
            if (serverConnected) {
                // Create the data object to sync
                const dataToSync = {
                    shiftSubmissions: workerSubmissions,
                    approvedWorkers: JSON.parse(localStorage.getItem('approvedWorkers') || '[]'),
                    preferencesLocked: localStorage.getItem('preferencesLocked') === 'true',
                    lockTimestamp: localStorage.getItem('lockTimestamp') || '',
                    lastUpdate: Date.now()
                };
                syncToGitHub(dataToSync);
            }
        }

        function refreshData() {
            if (serverConnected) {
                syncFromGitHub().then(() => {
                    updateAdminDashboard();
                    showAlert('Data refreshed from server!', 'success');
                });
            } else {
                loadSubmissions();
                updateAdminDashboard();
                showAlert('Data refreshed from local storage!', 'success');
            }
        }

        async function manualSync() {
            if (!serverConnected) {
                showAlert('Server is not connected. Please test connection first.', 'warning');
                return;
            }
            
            const syncBtn = document.getElementById('syncBtn');
            syncBtn.textContent = 'üîÑ Syncing...';
            syncBtn.disabled = true;
            
            try {
                updateSyncStatus('Manual sync in progress...', 'info');
                
                const downloadSuccess = await syncFromGitHub();
                
                // Create data to upload
                const dataToSync = {
                    shiftSubmissions: workerSubmissions,
                    approvedWorkers: JSON.parse(localStorage.getItem('approvedWorkers') || '[]'),
                    preferencesLocked: localStorage.getItem('preferencesLocked') === 'true',
                    lockTimestamp: localStorage.getItem('lockTimestamp') || '',
                    lastUpdate: Date.now()
                };
                
                const uploadSuccess = await syncToGitHub(dataToSync);
                
                if (downloadSuccess && uploadSuccess) {
                    showAlert('‚úÖ Manual sync completed successfully!', 'success');
                    updateSyncStatus('Manual sync completed', 'success');
                } else if (uploadSuccess) {
                    showAlert('‚ö†Ô∏è Upload successful, download had issues', 'warning');
                } else if (downloadSuccess) {
                    showAlert('‚ö†Ô∏è Download successful, upload had issues', 'warning');
                } else {
                    showAlert('‚ùå Manual sync failed', 'danger');
                }
                
                updateAdminDashboard();
            } catch (error) {
                showAlert('‚ùå Sync error: ' + error.message, 'danger');
                console.error('Manual sync error:', error);
            } finally {
                syncBtn.textContent = 'üîÑ Sync Now';
                syncBtn.disabled = false;
            }
        }

        function updateAdminDashboard() {
            document.getElementById('totalSubmissions').textContent = workerSubmissions.length;
            document.getElementById('pendingApprovals').textContent = 
                workerSubmissions.filter(s => !s.approved).length;
            
            const approvedWorkers = JSON.parse(localStorage.getItem('approvedWorkers') || '[]');
            document.getElementById('approvedWorkersCount').textContent = approvedWorkers.length;

            displayWorkerSubmissions();
            displayApprovedWorkers();
            updateLockStatus();
        }

        function togglePreferenceLock() {
            const isCurrentlyLocked = localStorage.getItem('preferencesLocked') === 'true';
            const newLockState = !isCurrentlyLocked;
            
            localStorage.setItem('preferencesLocked', newLockState.toString());
            localStorage.setItem('lockTimestamp', Date.now().toString());
            localStorage.setItem('lockSetBy', 'admin');
            localStorage.setItem('lastUpdate', Date.now().toString());
            
            updateLockStatus();
            
            if (serverConnected) {
                const dataToSync = {
                    shiftSubmissions: workerSubmissions,
                    approvedWorkers: JSON.parse(localStorage.getItem('approvedWorkers') || '[]'),
                    preferencesLocked: newLockState,
                    lockTimestamp: localStorage.getItem('lockTimestamp'),
                    lastUpdate: Date.now()
                };
                syncToGitHub(dataToSync);
            }
            
            if (newLockState) {
                showAlert('üîí Preferences locked! Workers can no longer submit or modify their preferences.', 'warning');
            } else {
                showAlert('üîì Preferences unlocked! Workers can now submit and modify their preferences.', 'success');
            }
        }

        function updateLockStatus() {
            const isLocked = localStorage.getItem('preferencesLocked') === 'true';
            const lockTimestamp = localStorage.getItem('lockTimestamp');
            const lockStatusDiv = document.getElementById('lockStatus');
            const toggleBtn = document.getElementById('toggleLockBtn');
            
            if (isLocked) {
                const lockTime = lockTimestamp ? new Date(parseInt(lockTimestamp)).toLocaleString() : 'Unknown';
                lockStatusDiv.className = 'lock-status locked';
                lockStatusDiv.innerHTML = `
                    <strong>üîí PREFERENCES LOCKED</strong><br>
                    <small>Locked since: ${lockTime}</small><br>
                    <small>Workers cannot submit or modify preferences while locked.</small>
                `;
                toggleBtn.textContent = 'üîì Unlock Preferences';
                toggleBtn.className = 'btn btn-success';
            } else {
                lockStatusDiv.className = 'lock-status unlocked';
                lockStatusDiv.innerHTML = `
                    <strong>üîì PREFERENCES UNLOCKED</strong><br>
                    <small>Workers can submit and modify their preferences.</small>
                `;
                toggleBtn.textContent = 'üîí Lock Preferences';
                toggleBtn.className = 'btn btn-warning';
            }
        }

        function displayApprovedWorkers() {
            const container = document.getElementById('approvedWorkersList');
            const approvedWorkers = JSON.parse(localStorage.getItem('approvedWorkers') || '[]');
            
            if (approvedWorkers.length === 0) {
                container.innerHTML = `
                    <div class="alert alert-warning" style="background: #fff3cd; color: #856404; border: 1px solid #ffeaa7;">
                        <strong>‚ö†Ô∏è No approved workers!</strong><br>
                        Workers cannot access the system until you add their names to the approved list.<br>
                        <small>Add worker names above to allow them to submit shift preferences.</small>
                    </div>
                `;
                return;
            }

            let html = '<h4>Approved Workers (' + approvedWorkers.length + '):</h4>';
            html += '<div style="display: flex; flex-wrap: wrap; gap: 10px; margin-top: 10px;">';
            
            approvedWorkers.forEach(workerName => {
                html += `
                    <div style="background: white; padding: 10px 15px; border-radius: 5px; border: 1px solid #dee2e6; display: flex; align-items: center; gap: 10px;">
                        <span style="font-weight: 500;">${workerName}</span>
                        <button onclick="removeWorker('${workerName.replace(/'/g, "\\'")}')" 
                                style="background: #dc3545; color: white; border: none; padding: 4px 8px; border-radius: 3px; cursor: pointer; font-size: 12px;">
                            ‚úï
                        </button>
                    </div>
                `;
            });
            
            html += '</div>';
            html += '<div style="margin-top: 10px; padding: 10px; background: #d4edda; border-radius: 5px; font-size: 12px; color: #155724;">';
            html += '<strong>‚úÖ Access Control Active:</strong> Only these workers can submit shift preferences. Workers must enter their exact name (case-insensitive) to access the system.';
            html += '</div>';

            container.innerHTML = html;
        }

        function addWorker() {
            const newWorkerName = document.getElementById('newWorkerName').value.trim();
            
            if (!newWorkerName) {
                showAlert('Please enter a worker name.', 'warning');
                return;
            }

            const approvedWorkers = JSON.parse(localStorage.getItem('approvedWorkers') || '[]');
            
            const existsAlready = approvedWorkers.some(name => 
                name.toLowerCase().trim() === newWorkerName.toLowerCase().trim()
            );

            if (existsAlready) {
                showAlert('Worker name already exists in the approved list.', 'warning');
                return;
            }

            approvedWorkers.push(newWorkerName);
            localStorage.setItem('approvedWorkers', JSON.stringify(approvedWorkers));
            localStorage.setItem('lastUpdate', Date.now().toString());
            
            if (serverConnected) {
                const dataToSync = {
                    shiftSubmissions: workerSubmissions,
                    approvedWorkers: approvedWorkers,
                    preferencesLocked: localStorage.getItem('preferencesLocked') === 'true',
                    lockTimestamp: localStorage.getItem('lockTimestamp') || '',
                    lastUpdate: Date.now()
                };
                syncToGitHub(dataToSync);
            }
            
            document.getElementById('newWorkerName').value = '';
            displayApprovedWorkers();
            updateAdminDashboard();
            
            showAlert(`Worker "${newWorkerName}" added successfully! They can now access the worker page.`, 'success');
        }

        function removeWorker(workerName) {
            if (confirm(`Are you sure you want to remove "${workerName}" from the approved workers list?`)) {
                let approvedWorkers = JSON.parse(localStorage.getItem('approvedWorkers') || '[]');
                
                approvedWorkers = approvedWorkers.filter(name => name !== workerName);
                localStorage.setItem('approvedWorkers', JSON.stringify(approvedWorkers));
                localStorage.setItem('lastUpdate', Date.now().toString());
                
                if (serverConnected) {
                    const dataToSync = {
                        shiftSubmissions: workerSubmissions,
                        approvedWorkers: approvedWorkers,
                        preferencesLocked: localStorage.getItem('preferencesLocked') === 'true',
                        lockTimestamp: localStorage.getItem('lockTimestamp') || '',
                        lastUpdate: Date.now()
                    };
                    syncToGitHub(dataToSync);
                }
                
                displayApprovedWorkers();
                updateAdminDashboard();
                
                showAlert(`Worker "${workerName}" removed successfully! They can no longer access the worker page.`, 'success');
            }
        }

        function testWorkerAccess() {
            const testName = document.getElementById('testWorkerName').value.trim();
            const resultDiv = document.getElementById('testResult');
            
            if (!testName) {
                resultDiv.innerHTML = '<div style="color: red; font-size: 12px;">Please enter a name to test.</div>';
                return;
            }

            const approvedWorkers = JSON.parse(localStorage.getItem('approvedWorkers') || '[]');
            const isApproved = approvedWorkers.some(name => 
                name.toLowerCase().trim() === testName.toLowerCase().trim()
            );

            if (isApproved) {
                resultDiv.innerHTML = `<div style="color: green; font-size: 12px;">‚úÖ "${testName}" would be GRANTED access to the worker page.</div>`;
            } else {
                resultDiv.innerHTML = `<div style="color: red; font-size: 12px;">‚ùå "${testName}" would be DENIED access to the worker page.</div>`;
            }
        }

        function displayWorkerSubmissions() {
            const container = document.getElementById('workerSubmissions');
            
            if (workerSubmissions.length === 0) {
                container.innerHTML = '<div class="alert alert-info">No worker submissions yet. Share the worker link to collect preferences.</div>';
                return;
            }

            let html = '';
            workerSubmissions.forEach(submission => {
                const availableShifts = Object.values(submission.preferences)
                    .reduce((count, day) => count + (day.morning ? 1 : 0) + (day.evening ? 1 : 0) + (day.night ? 1 : 0), 0);

                html += `
                    <div class="worker-card ${submission.approved ? 'approved' : ''}">
                        <h3>${submission.name} ${submission.approved ? '‚úÖ Approved' : '‚è≥ Pending'}</h3>
                        <p><strong>Available Shifts:</strong> ${availableShifts}/42 total</p>
                        <p><strong>Submitted:</strong> ${new Date(submission.submittedAt).toLocaleString()}</p>
                        
                        <div style="margin-top: 15px;">
                            <button class="btn ${submission.approved ? 'btn-secondary' : 'btn-success'}" 
                                    onclick="toggleApproval(${submission.id})">
                                ${submission.approved ? '‚úì Approved' : 'Approve'}
                            </button>
                            <button class="btn btn-danger" onclick="removeSubmission(${submission.id})">Remove</button>
                        </div>
                    </div>
                `;
            });

            container.innerHTML = html;
        }

        function toggleApproval(submissionId) {
            const submission = workerSubmissions.find(s => s.id === submissionId);
            if (submission) {
                submission.approved = !submission.approved;
                saveSubmissions();
                updateAdminDashboard();
                showAlert(`${submission.name} ${submission.approved ? 'approved' : 'unapproved'} successfully!`, 'success');
            }
        }

        function removeSubmission(submissionId) {
            const submission = workerSubmissions.find(s => s.id === submissionId);
            if (submission && confirm(`Are you sure you want to remove ${submission.name}'s submission?`)) {
                workerSubmissions = workerSubmissions.filter(s => s.id !== submissionId);
                saveSubmissions();
                updateAdminDashboard();
                showAlert('Submission removed successfully!', 'success');
            }
        }

        // Schedule generation functions
        function generateSchedule() {
            console.log('üîÑ Starting schedule generation...');
            
            // Get approved submissions only
            const approvedSubmissions = workerSubmissions.filter(s => s.approved);
            
            if (approvedSubmissions.length === 0) {
                showAlert('‚ùå No approved worker submissions found. Please approve some submissions first.', 'warning');
                return;
            }

            // Lock preferences during generation
            if (localStorage.getItem('preferencesLocked') !== 'true') {
                showAlert('üîí Locking preferences during schedule generation...', 'info');
                togglePreferenceLock();
            }

            try {
                showAlert('üîÑ Generating optimized schedule...', 'info');
                
                const schedule = generateOptimizedScheduleWithRules(approvedSubmissions);
                
                if (schedule) {
                    generatedScheduleData = schedule;
                    currentGeneration++;
                    displayGeneratedSchedule(schedule);
                    
                    // Update generation counter
                    const counterDiv = document.getElementById('generationCounter');
                    counterDiv.textContent = `Generation #${currentGeneration} completed at ${new Date().toLocaleString()}`;
                    
                    showAlert(`‚úÖ Schedule generated successfully! Assigned ${schedule.totalAssignments} shifts across ${schedule.days.length} days.`, 'success');
                } else {
                    showAlert('‚ùå Failed to generate schedule. Please check worker availability.', 'danger');
                }
            } catch (error) {
                console.error('Schedule generation error:', error);
                showAlert('‚ùå Error generating schedule: ' + error.message, 'danger');
            }
        }

        // Schedule generation functions with ground rules
        function generateSchedule() {
            console.log('üîÑ Starting schedule generation...');
            
            // Get approved submissions only
            const approvedSubmissions = workerSubmissions.filter(s => s.approved);
            
            if (approvedSubmissions.length === 0) {
                showAlert('‚ùå No approved worker submissions found. Please approve some submissions first.', 'warning');
                return;
            }

            // Lock preferences during generation
            if (localStorage.getItem('preferencesLocked') !== 'true') {
                showAlert('üîí Locking preferences during schedule generation...', 'info');
                togglePreferenceLock();
            }

            try {
                showAlert('üîÑ Generating optimized schedule...', 'info');
                
                const schedule = generateOptimizedScheduleWithRules(approvedSubmissions);
                
                if (schedule) {
                    generatedScheduleData = schedule;
                    currentGeneration++;
                    displayGeneratedSchedule(schedule);
                    
                    // Update generation counter
                    const counterDiv = document.getElementById('generationCounter');
                    counterDiv.textContent = `Generation #${currentGeneration} completed at ${new Date().toLocaleString()}`;
                    
                    showAlert(`‚úÖ Schedule generated successfully! Assigned ${schedule.totalAssignments} shifts across ${schedule.days.length} days.`, 'success');
                } else {
                    showAlert('‚ùå Failed to generate schedule. Please check worker availability.', 'danger');
                }
            } catch (error) {
                console.error('Schedule generation error:', error);
                showAlert('‚ùå Error generating schedule: ' + error.message, 'danger');
            }
        }

        function generateOptimizedScheduleWithRules(approvedSubmissions) {
            console.log('üìä Generating schedule for', approvedSubmissions.length, 'approved workers');
            
            const workers = approvedSubmissions.map(s => ({
                name: s.name,
                preferences: s.preferences,
                notes: s.notes,
                totalAssignments: 0,
                weeklyAssignments: [0, 0], // Week 1 (days 0-6), Week 2 (days 7-13)
                premiumShifts: 0,
                morningShiftsWeek1: 0,
                morningShiftsWeek2: 0,
                lastShiftDay: -1,
                lastShiftType: null,
                assignedShifts: [] // Track all assigned shifts: [{day, type}, ...]
            }));

            const schedule = {
                days: [],
                totalAssignments: 0,
                unfilledShifts: 0,
                workerStats: {},
                ruleViolations: [],
                generatedAt: new Date().toISOString()
            };

            // Initialize worker stats
            workers.forEach(worker => {
                schedule.workerStats[worker.name] = {
                    totalShifts: 0,
                    morningShifts: 0,
                    eveningShifts: 0,
                    nightShifts: 0,
                    premiumShifts: 0,
                    week1Shifts: 0,
                    week2Shifts: 0,
                    week1Mornings: 0,
                    week2Mornings: 0,
                    ruleViolations: []
                };
            });

            // Generate schedule for each day (14 days starting June 1st, 2025)
            const startDate = new Date(2025, 5, 1); // June 1st, 2025
            
            for (let day = 0; day < 14; day++) {
                const currentDate = new Date(startDate);
                currentDate.setDate(startDate.getDate() + day);
                
                const daySchedule = {
                    day: day,
                    date: currentDate.toLocaleDateString('en-GB'),
                    dayName: currentDate.toLocaleDateString('en-US', { weekday: 'short' }),
                    week: Math.floor(day / 7) + 1,
                    isWeekend: day === 5 || day === 6 || day === 12 || day === 13, // Weekend premium days
                    shifts: {
                        morning: { assigned: null, available: [], premium: day === 5 || day === 6 || day === 12 || day === 13 },
                        evening: { assigned: null, available: [], premium: day === 5 || day === 6 || day === 12 || day === 13 },
                        night: { assigned: null, available: [], premium: false }
                    }
                };

                // Find available workers for each shift
                workers.forEach(worker => {
                    if (worker.preferences[day]) {
                        if (worker.preferences[day].morning) {
                            daySchedule.shifts.morning.available.push(worker.name);
                        }
                        if (worker.preferences[day].evening) {
                            daySchedule.shifts.evening.available.push(worker.name);
                        }
                        if (worker.preferences[day].night) {
                            daySchedule.shifts.night.available.push(worker.name);
                        }
                    }
                });

                // Assign shifts using rule-based optimization algorithm
                assignShiftsForDay(daySchedule, workers, day, schedule);
                schedule.days.push(daySchedule);
            }

            // Calculate final statistics and check rule compliance
            calculateFinalStatistics(schedule, workers);
            checkRuleCompliance(schedule, workers);

            console.log('üìà Schedule generated:', {
                totalAssignments: schedule.totalAssignments,
                unfilledShifts: schedule.unfilledShifts,
                workers: workers.length,
                ruleViolations: schedule.ruleViolations.length
            });

            return schedule;
        }

        function assignShiftsForDay(daySchedule, workers, dayIndex, schedule) {
            const shifts = ['morning', 'evening', 'night'];
            
            shifts.forEach(shiftType => {
                const availableWorkers = daySchedule.shifts[shiftType].available;
                
                if (availableWorkers.length === 0) {
                    return; // No workers available for this shift
                }

                // Filter workers who can legally work this shift
                const eligibleWorkers = availableWorkers.filter(workerName => {
                    const worker = workers.find(w => w.name === workerName);
                    return canWorkerTakeShift(worker, dayIndex, shiftType, schedule);
                });

                if (eligibleWorkers.length === 0) {
                    console.warn(`‚ö†Ô∏è No eligible workers for ${shiftType} shift on day ${dayIndex}`);
                    return; // No eligible workers after rule checking
                }

                // Score each eligible worker
                const workerScores = eligibleWorkers.map(workerName => {
                    const worker = workers.find(w => w.name === workerName);
                    return {
                        name: workerName,
                        score: calculateWorkerScore(worker, dayIndex, shiftType, daySchedule.shifts[shiftType].premium)
                    };
                });

                // Sort by score (higher is better) and assign to best available worker
                workerScores.sort((a, b) => b.score - a.score);
                
                const selectedWorker = workerScores[0];
                daySchedule.shifts[shiftType].assigned = selectedWorker.name;
                
                // Update worker assignments
                const worker = workers.find(w => w.name === selectedWorker.name);
                assignShiftToWorker(worker, dayIndex, shiftType, daySchedule.shifts[shiftType].premium);
            });
        }

        function canWorkerTakeShift(worker, dayIndex, shiftType, schedule) {
            // Rule 1: 8-hour gap between shifts (no consecutive shifts)
            if (!checkEightHourRule(worker, dayIndex, shiftType)) {
                return false;
            }

            // Rule 2: Maximum 6 shifts per week
            const currentWeek = Math.floor(dayIndex / 7);
            if (worker.weeklyAssignments[currentWeek] >= 6) {
                return false;
            }

            return true;
        }

        function checkEightHourRule(worker, dayIndex, shiftType) {
            // Check if worker has a shift that would violate 8-hour rule
            for (const shift of worker.assignedShifts) {
                const timeBetween = calculateTimeBetweenShifts(shift.day, shift.type, dayIndex, shiftType);
                if (timeBetween < 8) {
                    return false;
                }
            }
            return true;
        }

        function calculateTimeBetweenShifts(day1, type1, day2, type2) {
            // Shift end times: morning=15, evening=23, night=7(next day)
            const shiftEndTimes = { morning: 15, evening: 23, night: 7 };
            const shiftStartTimes = { morning: 7, evening: 15, night: 23 };
            
            let end1 = day1 * 24 + shiftEndTimes[type1];
            if (type1 === 'night') {
                end1 += 24; // Night shift ends next day
            }
            
            const start2 = day2 * 24 + shiftStartTimes[type2];
            
            return start2 - end1;
        }

        function assignShiftToWorker(worker, dayIndex, shiftType, isPremium) {
            worker.totalAssignments++;
            const currentWeek = Math.floor(dayIndex / 7);
            worker.weeklyAssignments[currentWeek]++;
            
            if (isPremium) {
                worker.premiumShifts++;
            }
            
            if (shiftType === 'morning') {
                if (currentWeek === 0) {
                    worker.morningShiftsWeek1++;
                } else {
                    worker.morningShiftsWeek2++;
                }
            }
            
            worker.lastShiftDay = dayIndex;
            worker.lastShiftType = shiftType;
            worker.assignedShifts.push({ day: dayIndex, type: shiftType });
        }

        function calculateWorkerScore(worker, dayIndex, shiftType, isPremium) {
            let score = 1000; // Higher base score for better precision
            
            // Rule 2: Prefer workers with fewer weekly shifts (max 6 per week)
            const currentWeek = Math.floor(dayIndex / 7);
            const weeklyShifts = worker.weeklyAssignments[currentWeek];
            score -= weeklyShifts * 100; // Strong penalty for many weekly shifts
            
            // Rule 3: Strongly prefer workers without morning shifts this week for morning shifts
            if (shiftType === 'morning') {
                const morningShiftsThisWeek = currentWeek === 0 ? worker.morningShiftsWeek1 : worker.morningShiftsWeek2;
                if (morningShiftsThisWeek === 0) {
                    score += 200; // Strong bonus for workers without morning shifts
                } else {
                    score -= morningShiftsThisWeek * 150; // Penalty for workers with morning shifts
                }
            }
            
            // Rule 4: Premium shift distribution (Friday evening through Saturday evening)
            if (isPremium) {
                // Prefer workers with fewer premium shifts for fair distribution
                score -= worker.premiumShifts * 80;
                score += 50; // Small bonus for premium shifts to ensure they get filled
            }
            
            // General load balancing - prefer workers with fewer total shifts
            score -= worker.totalAssignments * 50;
            
            // Avoid overloading workers
            if (worker.totalAssignments >= 10) {
                score -= 300; // Heavy penalty for workers with many shifts
            }
            
            // Small randomization to break ties
            score += Math.random() * 20;
            
            return score;
        }

        function calculateFinalStatistics(schedule, workers) {
            schedule.days.forEach(day => {
                ['morning', 'evening', 'night'].forEach(shiftType => {
                    if (day.shifts[shiftType].assigned) {
                        schedule.totalAssignments++;
                        const workerName = day.shifts[shiftType].assigned;
                        const stats = schedule.workerStats[workerName];
                        
                        stats.totalShifts++;
                        stats[shiftType + 'Shifts']++;
                        
                        if (day.shifts[shiftType].premium) {
                            stats.premiumShifts++;
                        }
                        
                        if (day.week === 1) {
                            stats.week1Shifts++;
                            if (shiftType === 'morning') stats.week1Mornings++;
                        } else {
                            stats.week2Shifts++;
                            if (shiftType === 'morning') stats.week2Mornings++;
                        }
                    } else {
                        schedule.unfilledShifts++;
                    }
                });
            });
        }

        function checkRuleCompliance(schedule, workers) {
            workers.forEach(worker => {
                const stats = schedule.workerStats[worker.name];
                
                // Check Rule 2: Maximum 6 shifts per week
                if (stats.week1Shifts > 6) {
                    const violation = `${worker.name}: ${stats.week1Shifts} shifts in week 1 (max 6)`;
                    schedule.ruleViolations.push(violation);
                    stats.ruleViolations.push('Week 1: ' + stats.week1Shifts + ' shifts (max 6)');
                }
                if (stats.week2Shifts > 6) {
                    const violation = `${worker.name}: ${stats.week2Shifts} shifts in week 2 (max 6)`;
                    schedule.ruleViolations.push(violation);
                    stats.ruleViolations.push('Week 2: ' + stats.week2Shifts + ' shifts (max 6)');
                }
                
                // Check Rule 3: At least 1 morning shift per week (if they have any shifts)
                if (stats.week1Shifts > 0 && stats.week1Mornings === 0) {
                    const violation = `${worker.name}: No morning shifts in week 1`;
                    schedule.ruleViolations.push(violation);
                    stats.ruleViolations.push('Week 1: No morning shifts');
                }
                if (stats.week2Shifts > 0 && stats.week2Mornings === 0) {
                    const violation = `${worker.name}: No morning shifts in week 2`;
                    schedule.ruleViolations.push(violation);
                    stats.ruleViolations.push('Week 2: No morning shifts');
                }
            });
        }

        function displayGeneratedSchedule(schedule) {
            const container = document.getElementById('generatedSchedule');
            
            // Rule compliance summary
            let ruleComplianceClass = schedule.ruleViolations.length === 0 ? 'success' : 'warning';
            let ruleComplianceIcon = schedule.ruleViolations.length === 0 ? '‚úÖ' : '‚ö†Ô∏è';
            
            let html = `
                <div style="background: #e8f5e8; border: 1px solid #c3e6cb; border-radius: 8px; padding: 15px; margin-bottom: 20px;">
                    <h4>üìä Schedule Statistics</h4>
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 15px; margin-top: 10px;">
                        <div><strong>Total Assignments:</strong> ${schedule.totalAssignments}</div>
                        <div><strong>Unfilled Shifts:</strong> ${schedule.unfilledShifts}</div>
                        <div><strong>Coverage:</strong> ${Math.round((schedule.totalAssignments / (schedule.totalAssignments + schedule.unfilledShifts)) * 100)}%</div>
                        <div><strong>Generated:</strong> ${new Date(schedule.generatedAt).toLocaleString()}</div>
                    </div>
                </div>

                <div style="background: ${schedule.ruleViolations.length === 0 ? '#d4edda' : '#fff3cd'}; border: 1px solid ${schedule.ruleViolations.length === 0 ? '#c3e6cb' : '#ffeaa7'}; border-radius: 8px; padding: 15px; margin-bottom: 20px;">
                    <h4>${ruleComplianceIcon} Rule Compliance</h4>
                    ${schedule.ruleViolations.length === 0 ? 
                        '<div style="color: #155724;"><strong>‚úÖ All scheduling rules followed!</strong></div>' :
                        `<div style="color: #856404;"><strong>‚ö†Ô∏è ${schedule.ruleViolations.length} rule violations detected:</strong><ul style="margin: 10px 0 0 20px;">${schedule.ruleViolations.map(v => `<li>${v}</li>`).join('')}</ul></div>`
                    }
                    <div style="margin-top: 10px; font-size: 12px; opacity: 0.8;">
                        <strong>Rules:</strong> 1) 8-hour gap between shifts | 2) Max 6 shifts/week | 3) Min 1 morning/week | 4) Fair premium distribution
                    </div>
                </div>
            `;

            // Schedule table
            html += `
                <div style="overflow-x: auto;">
                    <table class="schedule-table">
                        <thead>
                            <tr>
                                <th style="text-align: left;">Day</th>
                                <th>Morning (07-15)</th>
                                <th>Evening (15-23)</th>
                                <th>Night (23-07)</th>
                            </tr>
                        </thead>
                        <tbody>
            `;

            schedule.days.forEach((day, index) => {
                const rowClass = day.isWeekend ? 'weekend-row' : '';
                html += `<tr class="${rowClass}">`;
                
                // Day column
                html += `
                    <td style="text-align: left; font-weight: bold;">
                        ${day.dayName} ${day.date}
                        <br><small style="color: #6c757d;">Week ${day.week}</small>
                        ${day.isWeekend ? '<br><small style="color: #856404;">üí∞ Premium Period</small>' : ''}
                    </td>
                `;
                
                // Shift columns
                ['morning', 'evening', 'night'].forEach(shiftType => {
                    const shift = day.shifts[shiftType];
                    
                    if (shift.assigned) {
                        const premiumBadge = shift.premium ? ' üí∞' : '';
                        html += `<td class="shift-assigned">
                            <strong>${shift.assigned}</strong>${premiumBadge}
                            <br><small>${shift.available.length} available</small>
                        </td>`;
                    } else {
                        html += `<td class="shift-unfilled">
                            <em>Unfilled</em>
                            <br><small>${shift.available.length} available</small>
                        </td>`;
                    }
                });
                
                html += '</tr>';
            });

            html += `
                        </tbody>
                    </table>
                </div>
            `;

            html += `
                <div class="schedule-container">
                    <h4>üë• Worker Statistics</h4>
                    <div class="worker-stats">
            `;

            Object.entries(schedule.workerStats).forEach(([workerName, stats]) => {
                html += `
                    <div class="worker-stat-card">
                        <h5 style="margin-bottom: 10px; color: #495057;">${workerName}</h5>
                        <div style="font-size: 12px; line-height: 1.4;">
                            <div><strong>Total Shifts:</strong> ${stats.totalShifts}</div>
                            <div><strong>Morning:</strong> ${stats.morningShifts} | <strong>Evening:</strong> ${stats.eveningShifts} | <strong>Night:</strong> ${stats.nightShifts}</div>
                            <div><strong>Weekend Shifts:</strong> ${stats.weekendShifts}</div>
                        </div>
                    </div>
                `;
            });

            html += `
                    </div>
                </div>
            `;

            container.innerHTML = html;
        } with rule compliance
            html += `
                <div class="schedule-container">
                    <h4>üë• Worker Statistics & Rule Compliance</h4>
                    <div class="worker-stats">
            `;

            Object.entries(schedule.workerStats).forEach(([workerName, stats]) => {
                const hasViolations = stats.ruleViolations.length > 0;
                const cardStyle = hasViolations ? 'border: 2px solid #ffc107; background: #fff3cd;' : '';
                
                html += `
                    <div class="worker-stat-card" style="${cardStyle}">
                        <h5 style="margin-bottom: 10px; color: #495057;">
                            ${workerName} ${hasViolations ? '‚ö†Ô∏è' : '‚úÖ'}
                        </h5>
                        <div style="font-size: 12px; line-height: 1.6;">
                            <div><strong>Total Shifts:</strong> ${stats.totalShifts}</div>
                            <div><strong>Week 1:</strong> ${stats.week1Shifts} shifts (${stats.week1Mornings} morning)</div>
                            <div><strong>Week 2:</strong> ${stats.week2Shifts} shifts (${stats.week2Mornings} morning)</div>
                            <div><strong>Premium Shifts:</strong> ${stats.premiumShifts} üí∞</div>
                            <div><strong>By Type:</strong> M:${stats.morningShifts} | E:${stats.eveningShifts} | N:${stats.nightShifts}</div>
                            ${hasViolations ? 
                                `<div style="color: #856404; margin-top: 8px; font-weight: bold;">
                                    <div>‚ö†Ô∏è Violations:</div>
                                    <ul style="margin: 4px 0 0 16px;">
                                        ${stats.ruleViolations.map(v => `<li>${v}</li>`).join('')}
                                    </ul>
                                </div>` : 
                                '<div style="color: #155724; margin-top: 8px; font-weight: bold;">‚úÖ All rules followed</div>'
                            }
                        </div>
                    </div>
                `;
            });

            html += `
                    </div>
                </div>
            `;

            // Premium shift distribution analysis
            const premiumDistribution = Object.entries(schedule.workerStats)
                .map(([name, stats]) => ({ name, premiumShifts: stats.premiumShifts }))
                .sort((a, b) => b.premiumShifts - a.premiumShifts);

            html += `
                <div class="schedule-container">
                    <h4>üí∞ Premium Shift Distribution (Friday Evening ‚Üí Saturday Evening)</h4>
                    <div style="background: #f8f9fa; padding: 15px; border-radius: 5px;">
                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 10px;">
                            ${premiumDistribution.map(worker => 
                                `<div style="background: white; padding: 10px; border-radius: 3px; text-align: center;">
                                    <strong>${worker.name}</strong><br>
                                    <span style="font-size: 18px; color: #ffc107;">${worker.premiumShifts} üí∞</span>
                                </div>`
                            ).join('')}
                        </div>
                        <div style="margin-top: 10px; font-size: 12px; color: #6c757d; text-align: center;">
                            Goal: Equal distribution of premium shifts across all workers
                        </div>
                    </div>
                </div>
            `;

            container.innerHTML = html;
        }html += `
                <div class="schedule-container">
                    <h4>üë• Worker Statistics</h4>
                    <div class="worker-stats">
            `;

            Object.entries(schedule.workerStats).forEach(([workerName, stats]) => {
                html += `
                    <div class="worker-stat-card">
                        <h5 style="margin-bottom: 10px; color: #495057;">${workerName}</h5>
                        <div style="font-size: 12px; line-height: 1.4;">
                            <div><strong>Total Shifts:</strong> ${stats.totalShifts}</div>
                            <div><strong>Morning:</strong> ${stats.morningShifts} | <strong>Evening:</strong> ${stats.eveningShifts} | <strong>Night:</strong> ${stats.nightShifts}</div>
                            <div><strong>Weekend Shifts:</strong> ${stats.weekendShifts}</div>
                        </div>
                    </div>
                `;
            });

            html += `
                    </div>
                </div>
            `;

            container.innerHTML = html;
        }

        function exportSchedule() {
            if (!generatedScheduleData) {
                showAlert('‚ùå No schedule to export. Please generate a schedule first.', 'warning');
                return;
            }

            try {
                let csvContent = 'Date,Day,Morning Shift,Evening Shift,Night Shift\n';
                
                generatedScheduleData.days.forEach(day => {
                    const morning = day.shifts.morning.assigned || 'Unfilled';
                    const evening = day.shifts.evening.assigned || 'Unfilled';
                    const night = day.shifts.night.assigned || 'Unfilled';
                    
                    csvContent += `${day.date},${day.dayName},${morning},${evening},${night}\n`;
                });

                // Create and download file
                const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
                const link = document.createElement('a');
                const url = URL.createObjectURL(blob);
                link.setAttribute('href', url);
                link.setAttribute('download', `shift_schedule_${new Date().toISOString().split('T')[0]}.csv`);
                link.style.visibility = 'hidden';
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                
                showAlert('‚úÖ Schedule exported as CSV file!', 'success');
            } catch (error) {
                console.error('Export error:', error);
                showAlert('‚ùå Failed to export schedule: ' + error.message, 'danger');
            }
        }

        function copyExcelFormat() {
            if (!generatedScheduleData) {
                showAlert('‚ùå No schedule to copy. Please generate a schedule first.', 'warning');
                return;
            }

            try {
                let excelContent = 'Date\tDay\tMorning Shift\tEvening Shift\tNight Shift\n';
                
                generatedScheduleData.days.forEach(day => {
                    const morning = day.shifts.morning.assigned || 'Unfilled';
                    const evening = day.shifts.evening.assigned || 'Unfilled';
                    const night = day.shifts.night.assigned || 'Unfilled';
                    
                    excelContent += `${day.date}\t${day.dayName}\t${morning}\t${evening}\t${night}\n`;
                });

                // Copy to clipboard
                navigator.clipboard.writeText(excelContent).then(() => {
                    showAlert('‚úÖ Schedule copied to clipboard in Excel format! Paste into Excel or Google Sheets.', 'success');
                }).catch(err => {
                    console.error('Clipboard error:', err);
                    showAlert('‚ùå Failed to copy to clipboard. Try using the CSV export instead.', 'warning');
                });
            } catch (error) {
                console.error('Copy error:', error);
                showAlert('‚ùå Failed to copy schedule: ' + error.message, 'danger');
            }
        }

        function clearAllData() {
            if (confirm('‚ö†Ô∏è Are you sure you want to clear ALL data? This will remove all worker submissions, generated schedules, AND approved worker names. This action cannot be undone.')) {
                if (confirm('This is your final warning. ALL data including approved worker names will be permanently deleted. Continue?')) {
                    workerSubmissions = [];
                    generatedScheduleData = null;
                    currentGeneration = 0;
                    totalPossibleGenerations = 0;
                    
                    localStorage.removeItem('approvedWorkers');
                    localStorage.removeItem('preferencesLocked');
                    localStorage.removeItem('lockTimestamp');
                    
                    saveSubmissions();
                    updateAdminDashboard();
                    
                    document.getElementById('generatedSchedule').innerHTML = 
                        '<div class="alert alert-info">No schedule generated yet. Click "Generate Optimized Schedule" to create one.</div>';
                    
                    showAlert('All data has been cleared, including approved worker names.', 'success');
                }
            }
        }

        function showAlert(message, type = 'info') {
            const alertClass = `alert-${type}`;
            const alertDiv = document.createElement('div');
            alertDiv.className = `alert ${alertClass}`;
            alertDiv.innerHTML = message;
            
            const content = document.querySelector('.content');
            content.insertBefore(alertDiv, content.firstChild);
            
            setTimeout(() => {
                alertDiv.remove();
            }, 5000);
        }

        // Initialize with Enter key support
        document.addEventListener('DOMContentLoaded', function() {
            setTimeout(() => {
                const newWorkerInput = document.getElementById('newWorkerName');
                if (newWorkerInput) {
                    newWorkerInput.addEventListener('keypress', function(e) {
                        if (e.key === 'Enter') {
                            addWorker();
                        }
                    });
                }
            }, 100);
        });

        // Cleanup interval on page unload
        window.addEventListener('beforeunload', function() {
            if (syncIntervalId) {
                clearInterval(syncIntervalId);
            }
        });
    </script>
</body>
</html>
